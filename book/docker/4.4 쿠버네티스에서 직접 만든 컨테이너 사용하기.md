# 쿠버네티스에서 직접 만든 컨테이너 사용하기
쿠버네티스에서 이미지를 사용하려면 쿠버네티스가 이미지를 불러올 수 있는 공간에 이미지를 넣어 두어야 한다.

## ✅ 쿠버네티스에서 도커 이미지 구동하기
쿠버네티스는 컨테이너를 효과적으로 다루기 위해서 만들어졌고 컨테이너인 파드도 쉽게 부를 수 있다. 따라서 직접 만든 컨테이너 이미지도 kubectl 명령으로 쿠버네티스 클러스터에서 바로 구동할 수 있다.

```shell
# m-k8s at super putty
docker images multistage-img
kubectl create deployment failure1 --image=multistage-img
kubectl get pods -w
kubectl create deployment failure2 --dry-run-client -o yaml \
--image=multistage-img > failure2.yaml
vi failure2.yaml
kubectl apply -f failure2.yaml
kubectl get pods
kubectl delete deployment failure1
kubectl delete deployment failure2
curl -O \
https://raw.githubusercontent.com/sysnet4admin/_Book_k8sInfra/main/ch4/4.3.4/Dockerfile
docker build -t multistage-img .
cp failure2.yaml success1.yaml
sed -i 's/replicas: 1/replicas: 3/' success1.yaml
sed -i 's/failure2/success1/' success1.yaml
kubectl apply -f success1.yaml
kubectl get pods -o wide
kubectl delete -f success1.yaml
docker rmi multistage-img
docker rmi $(docker images -f dangling=true -q)
```

```yaml
# failure2.yaml
    spec:
      containers:
      - image: multistage-img
        imagePullPolicy: Never # 추가한 부분
        name: multistage-img
        resource: {}
status: {}
```

## ✅ 레지스트리 구성하기
호스트에서 생성한 이미지를 쿠버네티스에서 사용하려면 모든 노드에서 공통으로 접근하는 레지스트리(저장소)가 필요하다.
제약 없이 사용할 수 있는 저장소가 필요하다면 레지스트리를 직접 구축하는 방법이 있다. 이 경우에는 인터넷을 연결할 필요가 없으므로 보안이 중요한 내부 전산망에서도 구현이 가능하다.

### 가장 많이 사용되는 레지스트리
- Quay(키): 레드헷에서 제공하는 이미지 레지스트리이다. 오픈 소스로 제공되는 무료 버전, 구입한 후 보유한 서버에 직접 설치해 사용할 수 있는 유료 버전, 비용을 지불하고 클라우드에서 이용할 수 있는 서비스형 상품이 있다.
- Harbor(하버): 클라우드 네이티브 컴퓨팅 재단의 지원을 받는 Project Harbor에서 오픈 소스로 제공하는 레지스트리이다. 도커 이미지 외에도 헬름 차트도 저장할 수 있다.
- Nexus Repository (넥서스 리포지터리): Sonatype에서 만든 레지스트리로, 오픈 소스로 제공되는 무료 버전과 유료 버전이 있다. 다양한 파일 형식의 파일을 저장할 수 있어서 여러 형식의 패키지를 하나의 저장소에 관리하려는 사용자에게 안성맞춤이다.
다양한 형식의 파일을 지원한다는 매력적인 특성 덕분에 레지스트리 중 가장 많은 사용자를 보유하고 있다.
- Docker Registry (도커 레지스트리): 도커에서 제공하는 레지스트리이다. 무료로 사용할 수 있고 도커 이미지만 저장할 수 있다.

### 실습: 사설 도커 레지스트리 만들기

```shell
# m-k8s at super putty
ls ~/_Book_k8sInfra/ch4/4.4.2
~/_Book_k8sInfra/ch4/4.4.2/create-registry.sh
docker ps -f name=registry
docker tag multistage-img 192.168.1.10:8443/multistage-img
docker images 192.168.1.10:8443/multistage-img
docker push 192.168.1.10:8443/multistage-img
curl https://192.168.1.10:8443/v2/_catalog -k
docker images | grep multi
docker rmi -f aa23
docker images | grep multistage
```
1. 사설 이미지 레지스트리 구성을 위한 파일들을 확인한다.

```shell
# tls.csr
[req]
distinguished_name = private_registry_cert_req
x509_extensions = v3_req
prompt = no

[private_registry_cert_req]
C = KR
ST = SEOUL
L = SEOUL
O = gilbut
OU = Book_k8sInfra
CN = 192.168.1.10

[v3_req]
keyUsage = keyEncipherment, dataEncipherment
extendedKeyUsage = serverAuth
subjectAltName = @alt_names

[alt_names]
DNS.0 = m-k8s
IP.0 = 192.168.1.10
```

```shell
#!/usr/bin/env bash
certs=/etc/docker/certs.d/192.168.1.10:8443
mkdir /registry-image
mkdir /etc/docker/certs
mkdir -p $certs
openssl req -x509 -config $(dirname "$0")/tls.csr -nodes -newkey rsa:4096 \
-keyout tls.key -out tls.crt -days 365 -extensions v3_req

yum install sshpass -y
for i in {1..3}
  do
    sshpass -p vagrant ssh -o StrictHostKeyChecking=no root@192.168.1.10$i mkdir -p $certs
    sshpass -p vagrant scp tls.crt 192.168.1.10$i:$certs
  done
  
cp tls.crt $certs
mv tls.* /etc/docker/certs

docker run -d \
  --restart=always \
  --name registry \
  -v /etc/docker/certs:/docker-in-certs:ro \
  -v /registry-image:/var/lib/registry \
  -e REGISTRY_HTTP_ADDR=0.0.0.0:443 \
  -e REGISTRY_HTTP_TLS_CERTIFICATE=/docker-in-certs/tls.crt \
  -e REGISTRY_HTTP_TLS_KEY=/docker-in-certs/tls.key \
  -p 8443:443 \
  registry:2
```

## ✅ 직접 만든 이미지로 컨테이너 구동하기
직접 만든 이미지를 쿠버네티스에서 불러서 파드를 만들 차례이다. 쿠버네티스에서 파드를 생성할 때 직접 구성한 레지스트리에서 가지고 오는 방법을 확인한다.

```shell
# m-k8s at super putty
cp success1.yaml success2.yaml
vi success2.yaml
sed -i 's/success1/success2/' success2.yaml
kubectl apply -f success2.yaml
kubectl gets pods -o wide
curl 172.16.132.5
curl 172.16.221.133
curl 172.16.103.133
kubectl delete -f success2.yaml
```

### Tip. 빌드한 도커 이미지를 통해 배포된 파드에 셸 접속이 되지 않아요.

```shell
# m-k8s at super putty
kubectl exec success2-6575dfbf95-gcc8d -it -- /bin/bash
cd ~/_Book_k8sInfra/ch4/4.4.3/echo-ip
docker build -t self-echo-ip .
docker tag self-echo-ip 192.168.1.10:8443/self-echo-ip
docker push 192.168.1.10:8443/self-echo-ip
```