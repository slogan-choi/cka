# 도커로 컨테이너 다루기
- 컨테이너 이미지와 컨테이너의 관계: 컨테이너 이미지는 그대로는 사용할 수 없고, 도커와 같은 CRI로 불러들여야 컨테이너가 실제로 작동한다.
따라서 컨테이너를 삭제할 때는 내려받은 이미지와 이미 실행된 컨테이너를 모두 삭제해야만 디스크의 용량을 온전히 확보할 수 있다.

## ✅ 컨테이너 이미지 알아보기
### 이미지 검색하고 내려받기
이미지는 레지스트리(registry)라고 하는 저장소에 모여 있다.
```shell
# m-k8s at super putty
docker search nginx
```
1. 현재 사용할 수 있는 nginx 이미지를 검색

- `INDEX`: 이미지가 저장된 레지스트리의 이름
- `NAME`: 검색된 이미지 이름, 공식 이미지를 제외한 나머지는 '레지스트리 주소/저장소 소유자/이미지 이름' 형태
- `DESCRIPTION`: 이미지에 대한 설명
- `STARS`: 해당 이미지를 내려받은 사용자에게 받은 평가 횟수
- `OFFICIAL`: [OK] 표시는 해당 이미지에 포함된 애플리케이션, 미들웨어 등을 개발한 업체에서 공식적으로 제공한 이미지라는 의미
- `AUTOMATED`: [OK] 표시는 도커 허브에서 자체적으로 제공하는 이미지 빌드 자동화 기능을 활용해 생성한 이미지를 의미

```shell
# m-k8s at super putty
docker pull nginx
```
1. docker search 로 찾은 이미지를 docker pull 로 내려받을 수 있다.

- `tag`: Using default tag 와 함께 뒤에 따라오는 태그 이름을 통해 이미지를 내려받을 때 사용한 태그를 알 수 있다. 아무런 조건을 주지 않고 이미지 이름만으로 pull을 수행하면 기본으로 latest 태그가 적용된다.
- `layer`: pull 을 수행해 내려받은 레이어이다. 하나의 이미지는 여러 개의 레이어로 이루어져 있어서 레이어마다 Pull complete 메시지가 발생한다.
- `digest`: 이미지의 고유 식별자로, 이미지에 포함된 내용과 이미지의 생성 환경을 식별할 수 있다. 식별자는 해시함수로 생성되며 이미지가 동일한지 검증하는데 사용한다.
- `status`: 이미지를 내려받은 레지스트리, 이미지, 태그 등의 상태 정보를 확인할 수 있다. 형식은 '레지스트리 이름/이미지 이름:태그' 이다.

### 이미지 태그
`태그`는 이름이 동일한 이미지에 추가하는 식별자이다. 이름이 동일해도 도커 이미지의 버전이나 플랫폼(CPU 종류나 기본 베이스를 이루는 운영 체제 등)이 다를 수 있기 때문에 이를 구분하는 데 사용한다.
이미지를 내려받거나 이미지를 기반으로 컨테이너를 구동할 때는 이미지 이름만 사용하고 태그를 명시하지 않으면 latest 태그를 기본으로 사용한다.

### 이미지의 레이어 구조
이미지는 같은 내용일 경우 여러 이미지에 `동일한 레이어를 공유`하므로 전체 용량이 감소한다.
도커로 작성된 컨테이너는 레이어를 재사용하기 때문에 여러 이미지를 내려받더라도 디스크 용량을 효율적으로 사용할 수 있다.

```shell
# 이미지의 레이어 구조 확인하기
# m-k8s at super putty
docker pull nginx:stable
docker images nginx
docker history nginx:stable
docker history nginx:latest
```
1. stable 이미지를 내려받는다.
2. 내려받은 이미지를 조회한다.
3. stable 이미지가 어떤 과정을 거쳐 생성됐는지 확인한다.
4. latest 이미지의 생성 과정과 용량을 확인한다.

## ✅ 컨테이너 실행하기

### 컨테이너 단순히 실행하기
```shell
# m-k8s at super putty
docker run -d --restart always nginx
docker ps
docker ps -f id=cec7
curl 127.0.0.1
```
1. 새로운 컨테이너를 실행한다.
   - -d(--detach): 컨테이너를 백그라운드에서 구동한다는 의미이다.
   - --restart always: 컨테이너의 재시작과 관련된 정책을 의미하는 옵션이다.

Tip. --restart 옵션에 따라 달라지는 컨테이너 시작 방법

| 값 | 컨테이너 비정상 종료 시 | 도커 서비스 시작 시 |
|---|---|---|
| no(기본값) | 컨테이너를 재시작하지 않음 | 컨테이너를 시작하지 않음 |
| on-failure | 컨테이너를 재시작함 | 컨테이너를 시작함 |
| always | 컨테이너를 재시작함 | 컨테이너를 시작함 |
| unless-stopped | 컨테이너를 재시작함 | 사용자가 직접 정지하지 않은 컨테이너만 시작함 |

2. docker ps 명령으로 생성한 컨테이너 상태를 확인한다.
- `CONTAINER ID`: 컨테이너를 식별하기 위한 고유 ID 이다.
- `IMAGE`: 컨테이너를 만드는데 사용한 이미지
- `COMMAND`: 컨테이너가 생성될 때 내부에서 작동할 프로그램을 실행하는 명령어
- `CREATED`: 컨테이너가 생성된 시각을 표시
- `STATUS`: 컨테이너가 작동을 시작한 시각을 표시한다. 컨테이너가 중지했다가 다시 시작할 경우 초기화된다.
- `PORTS`: 컨테이너가 사용하는 포트와 프로토콜을 표시한다.
- `NAMES`: 컨테이너 이름을 표시한다. docker run 에 --name <이름> 옵션으로 직접 지정할 수도 있지만, 지정하지 않으면 컨테이너가 시작될 때 도커가 임의로 부여한 값이 나타난다.

3. docker ps -f id=cec7 명령으로 컨테이너를 지정해 검색한다. (16진수 ID를 넣어야 한다.)
docker ps -f(--filter) <필터링 대상> 옵션을 주면 검색 결과를 필터링 할 수 있다.

Tip. 자주 사용하는 필터링 키

필터링에 주로 사용하는 키(key) 는 다음과 같다.
- `id`: 컨테이너 아이디
- `name`: 컨테이너 이름
- `label`: 컨테이너 레이블
- `exited`: 컨테이너가 종료됐을 때 반환하는 숫자 코드
- `status`: 컨테이너의 자동 상태
- `ancestor`: 컨테이너가 사용하는 이미지

4. 생성된 nginx 컨테이너는 마스터 노드 내부에 존재하므로 curl 127.0.0.1 명령으로 컨테이너가 제공하는 nginx 웹 페이지 정보를 가지고 오게 한다. `에러 발생`
- 앞에서 컨테이너의 PORTS 열에 표시되는 80/tcp 는 컨테이너 내부에서 TCP 프로토콜의 80번 포트를 사용한다는 의미이다. 하지만 curl 127.0.0.1 로 전달한 요청은 로컬 호스트(127.0.0.1)의 80번 포트로 전달만 될 뿐 컨테이너까지는 도달하지 못한다.
즉 `호스트에 도달한 후 컨테이너로 도달하기 위한 추가 경로 설정이 돼 있지 않다.`

### 추가로 경로를 설정해 정상적으로 컨테이너 실행하기
- 컨테이너 외부에서도 컨테이너 내부에 접속할 수 있게 새로운 컨테이너를 구동해보자
```shell
# m-k8s at super putty
docker run -d -p 8080:80 --name nginx-exposed --restart always nginx
docker ps -f name=nginx-exposed
```
1. -p(--publish) 는 외부에서 호스트로 보낸 요청을 컨테이너 내부로 전달하는 옵션으로, -p <요청 받을 호스트 포트>:<연결할 컨테이너 포트> 형식으로 사용한다.
2. 컨테이너가 제대로 동작하는지 확인한다.
   - `0.0.0.0:8080->80/tcp`: 0.0.0.0의 8080번 포트로 들어오는 요청을 컨테이너 내부의 80번 포트로 전달하는 의미이다. 0.0.0.0은 존재하는 모든 네트워크 어댑터를 의미한다.

```http request
192.168.1.10:8080
```
3. 웹 브라우저에서 IP 를 입력해 가상 머신을 호스팅하는 PC나 노트북에서 컨테이너로 접근할 수 있는지 확인한다.

## ✅ 컨테이너 내부 파일 변경하기
- 컨테이너 내부에서 웹 페이지 파일을 변경할 수 있지만 이런 경우, 컨테이너를 다시 생성하게 되면 매번 웹 페이지 파일을 전송해야 한다. 그러므로 영속적으로 웹 페이지 파일을 사용하기 위해서는 특정 디렉터리와 컨테이너 내부의 디렉터리를 연결하는 것이 효과적인 사용법이다.
### 컨테이너 내부에서 컨테이너 외부의 파일을 사용할 수 있는 방법
- `docker cp`: docker cp <호스트 경로> <컨테이너 이름>:<컨테이너 내부 경로> 형식으로 호스트에 위치한 파일을 구동 중인 컨테이너 내부에 복사한다.
따라서 컨테이너에 임시로 필요한 파일이 있는 경우 단편적으로 전송하기 위해서 사용한다. 또는 컨테이너에 저장돼 있는 설정 및 로그를 추출해 확인하는 목적으로도 사용한다.
- `Dockerfile ADD`: 이미지는 Dockerfile 을 기반으로 만들어지는데, 이때 Dockerfile 에 ADD 라는 구문으로 컨테이너 내부로 복사할 파일을 지정하면 이미지를 빌드할 때 지정한 파일이 이미지 내부로 복사된다.
- `바인드 마운트`: 호스트의 파일 시스템과 컨테이너 내부를 연결해 어느 한쪽에서 작업한 내용이 양쪽에 동시에 반영되는 방법이다.
데이터베이스의 데이터 디렉터리나 서버의 첨부 파일 디렉터리처럼 컨테이너가 바뀌어도 없어지면 안 되는 자료는 이 방법으로 보전할 수 있다.
- `볼륨`: 호스트의 파일 시스템과 컨테이너 내부를 연결하는 것은 바인드 마운트와 동일하지만, 호스트의 특정 디렉터리가 아닌 도커가 관리하는 볼륨을 컨테이너와 연결한다.
도커가 관리하는 볼륨 공간을 NFS 와 같은 공유 디렉터리에 생성한다면 다른 호스트에서도 도커가 관리하는 볼륨을 함께 사용할 수 있다.

표 4-3. 컨테이너 내부에서 외부 파일을 사용하는 방법

| 구분 | docker cp | Dockerfile ADD | 바인드 마운트 | 볼륨 |
|---|---|---|---|---|
| 컨테이너 적용 | 구동 중 복사 | 이미지 생성 시 복사 | 구동 시 디렉터리 연결 | 구동 시 도커의 볼륨 연결 |
| 파일 보관 위치 | 컨테이너 내부 | 컨테이너 내부 | 호스트(디렉터리) | 호스트(도커 볼륨) |
| 주 활용 용도 | 임시 파일 | 컨테이너 생성 시 필요한 파일 | 보존이 필요한 파일 | 보존이 필요한 파일 |
| 관리 편의성 | 좋지 못함 | 좋음 | 좋음 | 매우 좋음 |
| 파일 보존성 | 좋지 못함 | 좋음 | 매우 좋음 | 매우 좋음 |

### 바인드 마운트로 호스트와 컨테이너 연결하기
호스트와 컨테이너를 연결하려면 연결 대상이 되는 컨테이너 내부의 디렉터리 구조를 먼저 알아야 한다. 수정해야 할 파일 경로는 nginx 의 경우 /etc/nginx/nginx.conf 이다.

```shell
# m-k8s at super putty
mkdir -p /root/html
docker run -d -p 8081:80 \
-v /root/html:/usr/share/nginx/html --restart always --name nginx-bind-mounts nginx
docker ps -f name=nginx-bind-mounts
ls /root/html
```
1. 컨테이너 내부에 연결할 /root/html/ 디렉터리를 호스트에 생성한다.
2. docker run 명령으로 nginx-bind-mounts 라는 이름의 컨테이너를 구동하고, 컨테이너의 /usr/share/nginx/html/ 디렉터리와 호스트의 /root/html/ 디렉터리를 연결한다.
-v(-volume)는 호스트 디렉터리와 컨테이너 디렉터리를 연결하는 옵션으로, -v <호스트 디렉터리 경로>:[컨테이너 디렉터리 경로] 형식으로 사용한다.
   - `바인트 마운트 특징`: 호스트 디렉터리의 내용을 그대로 컨테이너 디렉터리에 덮어쓴다는 점이다. 따라서 컨테이너 디렉터리에 어떠한 내용이 있더라도 해당 내용은 삭제된다는 것에 유의한다.
3. nginx-bind-mounts 컨테이너를 조회해 status 가 정상(Up n minutes) 인지 확인한다.
4. 컨테이너 내부와 연결된 /root/html/ 디렉터리를 확인한다. 빈 디렉터리 이다.

```http request
192.168.1.10:8081
```
5. 웹 브라우저를 열고 IP 에 연결해 nginx-bind-mounts 컨테이너에서 실행되는 nginx 에 접속되는지 확인한다. `에러 발생`
바인드 마운트 설정에 따라 호스트 디렉터리의 /root/html 에 있는 index.html 을 노출하려고 하지만 해당 파일이 존재하지 않기 때문에 403 Forbidden 오류 화면이 출력 된다. 

```shell
# m-k8s at super putty
cp ~/_Book_k8sInfra/ch4/4.2.3/index-BindMount.html /root/html/index.html
ls /root/html
```
6. cp 명령어로 호스트 디렉터리와 컨테이너 디렉터리를 연결할 때 사용할 index.html 을 /root/html/ 에 복사한다.
7. 해당 디렉터리에 제대로 저장됐는지 확인한다.

```http request
192.168.1.10:8081
```
8. 브라우저에서 IP로 다시 접속해 index.html 이 표시되는지 확인한다.

Tip. 컨테이너 내부 확인하기
```shell
# m-k8s at super putty
docker exec e7ca ls /usr/share/nginx/html
```
호스트 디렉터리와 컨테이너 디렉터리가 연결된 경우에 컨테이너 내부를 보려면 docker exec <컨테이너 ID | 이름> <명령어> 형식으로 실행하면 컨테이너에서 명령을 실행하고 결과를 보여 준다.

### 볼륨으로 호스트와 컨테이너 연결하기
볼륨(volume) 은 도커가 직접 관리하며 컨테이너에 제공하는 호스트의 공간이다.

- `볼륨 vs. 바인드 마운트`: 호스트 디렉터리를 컨테이너 디렉터리에 덮어쓰는 구조가 아니라 양쪽을 서로 동기화시키는 구조이기 때문에 비어 있는 볼륨을 연결하는 경우에는 컨테이너 디렉터리에 있는 파일이 보존된다.
하지만 볼륨에 컨테이너 디렉터리와 동일한 파일이 존재한 상태로 연결하는 경우에는 덮어쓰기가 된다.

```shell
# m-k8s at super putty
docker volume create nginx-volume
docker volume inspect nginx-volume
ls /var/lib/docker/volumes/nginx-volume/_data
docker run -d -v nginx-volume:/usr/share/nginx/html \
-p 8082:80 --restart always --name nginx-volume nginx
ls /var/lib/docker/volume/nginx-volume/_data
```
1. 볼륨을 생성한다. 이름 nginx-volume 이다.
2. 생성된 볼륨을 조회한다. 볼륨에 적용된 드라이버 종류와 실제 호스트에 연결된 디렉터리, 볼륨 이름 등을 조회할 수 있다. Mountpoint 행의 값이 볼륨 디렉터리이다.
컨테이너 내부와 연결할 때 전체 디렉터리 경로를 사용하지 않고 nginx-volumne 이라는 볼륨 이름만으로 간편하게 연결할 수 있다.
3. 볼륨으로 생성된 디렉터리를 확인한다. 빈 디렉터리 이다.
4. 호스트와 컨테이너의 디렉터리를 연결할 새로운 컨테이너를 구동한다. nginx-volume 라는 이름의 컨테이너를 구동하고 컨테이너 내부의 /usr/share/nginx/html/ 디렉터리와 호스트의 nginx-volume 볼륨을 연결한다.
사용하는 옵션은 -v [볼륨 이름]:[컨테이너 디렉터리] 이다.
5. 볼륨 디렉터리의 내용을 다시 확인한다. 바인드 마운트와 달리 볼륨은 빈 디렉터리를 덮어쓰지 않고 컨테이너 내부에 있는 `50x.html` 과 `index.html` 파일은 보존된다. 

> 작동 중인 컨테이너의 설정을 변경할 수 없다. 컨테이너는 `변경 불가능한 인프라`를 지향한다. 따라서 컨테이너에 적용된 설정을 변경하려면 새로운 컨테이너를 생성해야 한다.

```http request
192.168.1.10.:8082
```
6. 웹 브라우저로 IP를 연결해 nginx-volume 컨테이너의 nginx 에 접속한다.

```shell
# m-k8s at super putty
cp ~/_Book_k8sInfra/ch4/4.2.3/index-Volume.html /var/lib/docker/volumes/nginx-volume/_data/index.html
```
7. nginx-volume 에 cp 명령어로 바꿀 파일을 볼륨 디렉터리로 복사해 볼륨에서 변경한 내용이 컨테이너 디렉터리에 동기화되는지 테스트한다.

```http request
192.168.1.10.:8082
```
8. 웹 브라우저에서 192.168.1.10:8082 를 다시 연결하면 바뀐 index.html 의 내용으로 표시된다.

> 볼륨을 사용하면 컨테이너에 존재하는 파일을 그대로 보전할 수 있고, 필요할 때 변경해서 사용할 수도 있다. 또한, 사용 중인 볼륨을 `docker volume ls` 명령으로 조회, `docker volume rm` 명령으로 삭제할 수도 있어서 바인드 마운트보다 관리하기 더 쉽다.

Tip. 대량의 데이터를 저장하고 연결하려는 목적으로 볼룸을 사용하는 경우라면 기본 디렉터리가 아닌 충분한 용량이 확보된 디렉터리 경로로 설정해야 할 필요가 있다.
도커 버전에 따라 경로를 분리하는 기느의 지원 여부가 다르다. docker-ce 17.05 버전 부터는 도커의 데몬 설정에서 볼륨이 저장되는 경로를 지정하는 `--data-root` 옵션이나 호스트 경로와 컨테이너 경로를 명확하게 연결하는 `--mount` 옵션을 제공한다.
참고로 docker volume create 를 실행할 때 기본으로 설정된 /var/lib/docker/volumes/ 디렉터리이다.

## ✅ 사용하지 않는 컨테이너 정리하기
사용이 끝나고 더 이상 사용하지 않을 컨테이너라면 공간을 확보하기 위해 삭제하는 것이 좋다.

### 컨테이너 정지하기
```shell
docker ps -f ancestor=nginx
docker stop tender_snyder
docker stop f530
docker ps -q -f ancestor=nginx
docker stop $(docker ps -q -f ancestor=nginx)
docker ps -f ancestor=nginx
docker ps -a -f ancestor=nginx
```
1. nginx 이미지를 기반으로 생성된 컨테이너를 조회한다.
2. 컨테이너를 정지한다. docker stop <컨테이너 이름 | ID>
3. 컨테이너를 정지한다. docker stop <컨테이너 이름 | ID>
4. nginx 이미지를 사용하는 모든 컨테이너를 조회 명령에 -q(--quite) 옵션을 추가해 컨테이너 ID만 출력한다.
5. nginx 를 이미지로 사용하는 모든 컨테이너를 정지한다.
6. 모든 컨테이너가 정지됐는지 확인한다.
7. docker ps -a(--all) 옵션을 주면 정지된 컨테이너를 포함해 nginx 이미지를 기반으로 생성한 컨테이너가 모두 조회된다.
이때 정지한 컨테이너를 다시 구동하고 싶다면 docker start <컨테이너 이름 | ID>를 실행한다.

### 컨테이너와 이미지 삭제하기
정지한 컨테이너가 더 이상 필요 없으면 삭제해 사용 중인 컨테이너 목록을 관리하고, 사용하지 않는 컨테이너 이미지를 삭제해 저장 공간을 확보한다.
```shell
docker rm $(docker ps -aq -f ancestor=nginx)
docker ps -a -f ancestor=nginx
docker rmi $(docker images -q nginx)
```
1. 컨테이너는 docker rm <컨테이너 이름 | ID> 명령으로 삭제한다. 위 명령은 현재 정지된 모든 컨테이너를 삭제한다.
docker rm 에 -f(--force) 옵션을 붙여 실행 중인 컨테이너를 강제로 삭제한다. 강제로 삭제하면 의도하지 않은 삭제가 일어날 수 있으니 주의한다.
2. 모든 컨테이너가 삭제되면 조회되는 컨테이너가 없다.
3. docker rmi(remove image) 명령으로 이미지를 삭제한다. 참고로 이미지는 컨테이너가 정지 상태가 아닌 삭제 상태일 때 삭제할 수 있다. 따라서 이미지를 삭제하기 전에 컨테이너를 삭제해야 한다.